<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.4">
  <POU Name="Sorter" Id="{3b431d4d-c25c-406a-aef2-7598ac3d07f6}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM Sorter
VAR
	nSorterClearIdx				: DINT;
	bSimulate					: BOOL := FALSE;	// Indicates when runing a simulation
	BlankItem					: ST_Item := (ID := ''
												, UniqueID := 0
												, Destination := 0
												, Status := E_StatusCode.No_Status
												, ExtStatus := E_StatusCode.No_Status
												, DeviceID := ''
												, MessageType := E_MessageIds.NoMessage_00);
	
	st_ToInduct					: ST_ItemTemporary;	// This is the next item to be inducted onto the sorter
	st_Inducting				: ST_ItemTemporary;	// This is the next item to be inducted onto the sorter
	st_InductUpdate				: ST_ItemTemporary;	// This is to update an item already being inducted
	{attribute 'OPC.UA.DA' := '1'}
	st_Sorter					: ST_Sorter;
	//{attribute 'OPC.UA.DA' := '1'}
	//aSorterDiverts 				: ARRAY[DIVERTMIN..NUMBEROFDIVERTS] OF ST_Divert;

	st_SorterEncoder 			: ST_Encoder;
	fb_SorterEncoder 			: FB_ProcessEncoder;
	{attribute 'OPC.UA.DA' := '1'}
	ENC_Raw	AT %I*:	UINT;	// Raw Encoder Value
	tEncoderOK			: TON;
	nLastEncoderCount	: UDINT;

	{attribute 'OPC.UA.DA' := '1'}
	fb_SortMetrics				: FB_Metrics;

	In_DefaultDestination AT %I*	: DINT;	// Input default destination update from Host messaging(MsgControl.RECEIVE)

	fb_CommissionSorterDiverts	: FB_DivertCommission;
	rInductPE					: R_TRIG; 	// Capture the Rising edge of the Induct PE
	fInductPE					: F_TRIG; 	// Capture the Falling edge of the Induct PE

	rDischargePE				: R_TRIG; 	// Capture the Rising edge of the Discharge PE
	fDischargePE				: F_TRIG; 	// Capture the Falling edge of the Discharge PE

	st_TempItem					: ST_ItemTemporary;	// Store temporary Item info until BCR data is received

	DivertToCommission			: UINT := 0;	// Non-zero value will send all items to this divert

	sMessage			: STRING;

	ClearSorterArray	: BOOL;

//----------------------------------------------DivertCfg---------------------------------------------------------------------
	Dummy : BOOL;
	Divert_RTRIG	:	ARRAY[1..16] OF R_TRIG;
	Divert_FTRIG	:	ARRAY[1..16] OF F_TRIG;
	
	PE23201_Full AT %I*	:	BOOL;	
	
	Diverts			: ARRAY[Sorter.DIVERTMIN..Sorter.NUMBEROFDIVERTS] OF ST_Divert;
	DivertsCfgs		: ARRAY[Sorter.DIVERTMIN..Sorter.NUMBEROFDIVERTS] OF ST_DivertCfg;
	


END_VAR

VAR PERSISTENT
	aSorterItems 				: ARRAY[SORTERENCODERMIN..SORTERENCODERMAX] OF ST_Item;	// Persist the Items to Sort array
	{attribute 'OPC.UA.DA' := '1'}
	st_SorterCfg				: ST_SorterConfig; 	// Persist Sorter configuration
	{attribute 'OPC.UA.DA' := '1'}
	st_DivertCfgs 				: ARRAY[DIVERTMIN..NUMBEROFDIVERTS] OF ST_DivertCfg; 	// Persist Sorter Configuration
END_VAR

VAR CONSTANT
	SORTERMASKSIZE				: UINT := 11;		// Number of bits to mask into the Encoder Count, will define the size of the SORTERENCODERMAX value
	{attribute 'OPC.UA.DA' := '1'}
	NUMBEROFDIVERTS				: DINT := 5;
	DIVERTMIN					: DINT := 1;
	{attribute 'OPC.UA.DA' := '1'}
	SORTERENCODERMAX			: UDINT := ((LREAL_TO_UDINT(EXPT(2,SORTERMASKSIZE)))-1); // Calculated size based on the bitmask 
	{attribute 'OPC.UA.DA' := '1'}
	SORTERENCODERMIN			: UDINT := 0;

	DIVERT1:	INT := 0;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Sorter clear when the system is restarted or downloaded (INIT=TRUE for first scan)
IF (GVL_IO.INIT AND NOT st_SorterCfg.RetainOnRestart) OR ClearSorterArray THEN
	FOR nSorterClearIdx := UDINT_TO_DINT(SORTERENCODERMIN) TO UDINT_TO_DINT(SORTERENCODERMAX) BY 1 DO
		IF nSorterLogEnable.SORTER_DUMP THEN
			IF aSorterItems[nSorterClearIdx].ID <> '' THEN
				IF .nSorterLogEnable.SORTER_DUMP THEN
					sMessage := CONCAT(' Item: ', aSorterItems[nSorterClearIdx].ID);
					sMessage := CONCAT(sMessage,' Index: ');
					sMessage := CONCAT(sMessage, DINT_TO_STRING(nSorterClearIdx));
					// Write to the Error List
					ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
						, msgFmtStr := 'Array Dump Info: %s'
						, strArg := sMessage);
				END_IF
			END_IF
		END_IF
		aSorterItems[nSorterClearIdx] := BlankItem;
	END_FOR
	ClearSorterArray := FALSE;
END_IF

// Setup and process the Sorter Encoder
st_SorterEncoder.EncoderRawCount := ENC_Raw;
st_SorterEncoder.BitMaskSize := SORTERMASKSIZE;
fb_SorterEncoder(Encoder := st_SorterEncoder, Simulate := bSimulate);

(*
	DivertCfg Initializes the Diverts.  
*)
//DivertCfg(Diverts := aSorterDiverts
		//	, DivertsCfgs := st_DivertCfgs);

fb_CommissionSorterDiverts(
			InductTrigger := Photoeyes.PE_7171.Out,
			ReferenceValue := st_SorterEncoder.CurrentCount, 
			DischargeTrigger := Photoeyes.PE_8211.Out_OffFltrd,
			TestTime := T#10S, Diverts := Diverts);

// Provide a "hard-coded" default destination.
IF st_SorterCfg.DefaultDestination <= 0 THEN
	st_SorterCfg.DefaultDestination := 5;
END_IF						

// Name of the sorter equipment
st_SorterCfg.Name := Conveyors.cfgP6040Label;
st_SorterCfg.DivertCount := NUMBEROFDIVERTS;
IF DivertToCommission > 0 THEN
	st_SorterCfg.DefaultDestination := DivertToCommission;
END_IF
st_Sorter.EncoderCounts := st_SorterEncoder.CurrentCount;
st_Sorter.InductPE := PhotoEyes.PE_7171.Out_OnFltrd;
st_Sorter.DischargePE := Photoeyes.PE_8211.Out_OnFltrd;

// Test the Encoder
tEncoderOK.IN := (Conveyors.P6040_Status.Sts_IsRunning AND (st_Sorter.EncoderCounts = nLastEncoderCount));
tEncoderOK(PT:=T#1S);

// OK when Q is not on, but the alarm is reversed
GVL_IO.ENC_9021_OK := tEncoderOK.Q;

// Publish the sorter name
GVL_IO.SorterName := st_SorterCfg.Name;

// Sorter
(*
	ProcessBuffers processes all associated buffers (Sorter/Divert/Arrival/Transport/Update)
	Items arriving at the sorter are detected and processed in this function block then deliverd to the SorterProgram
	Items inducted into sorter produce TransportResponse messages in this function block
	Items diverted off the sorter produce TransportComplete messages in this function block
*)
ProcessBuffers(st_NextToInduct := st_ToInduct
				, st_TempInductItem := st_TempItem
				, st_UpdateItem := st_Inducting
				, st_Sorter := st_Sorter
				, aDiverts := Diverts
				, aItems := aSorterItems
				, DivertToCommission := DivertToCommission);

// Capture rising and falling edge Triggers of the configured Sorter PE (Induct/Discharge)
rInductPE(CLK:= st_Sorter.InductPE, Q =>);
fInductPE(CLK:= st_Sorter.InductPE, Q =>);
rDischargePE(CLK:= st_Sorter.DischargePE, Q =>);
fDischargePE(CLK:= st_Sorter.DischargePE, Q =>);

// Prepare a dummy record for items that arrive before BCR data is received
// On the rising edge of the Induct PE
IF rInductPE.Q THEN
	IF .nSorterLogEnable.SORTER_INDUCT_PE THEN
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Induct PE Blocked : %s'
			, strArg := BOOL_TO_STRING(st_Sorter.InductPE)); 
	END_IF
	// Test for a UniqueID, which indicates that a Barcode has been received
	IF st_ToInduct.Item.UniqueID = 0 THEN
		// Capture and create relevant info
		st_TempItem.Counts := st_Sorter.EncoderCounts;
		st_TempItem.Item.UniqueID :=  UDINT_TO_DINT(st_Sorter.EncoderCounts);
		st_TempItem.Item.ID :=  CONCAT('T-', UDINT_TO_STRING(st_Sorter.EncoderCounts));
		st_TempItem.Item.Destination := st_SorterCfg.DefaultDestination;
		st_TempItem.Item.Status := E_StatusCode.UnidentifiedItem;
		IF .nSorterLogEnable.SORTER_TEMPID THEN
			ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
				, msgFmtStr := 'Temp ID Assigned : %s'
				, strArg := st_TempItem.Item.ID);
		END_IF
	END_IF	
END_IF

// Clear the dummy record when the PE clears
// Items can only be inducted when the BCR info is received before or while the induct PE is blocked
IF fInductPE.Q THEN
	IF .nSorterLogEnable.SORTER_INDUCT_PE THEN
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Induct PE Blocked : %s'
			, strArg := BOOL_TO_STRING(st_Sorter.InductPE));
	END_IF
	// Clear the record
	st_TempItem.Counts := 0;
	st_TempItem.Item :=  BlankItem;
END_IF

(*
	SorterProgram is a separate Program
	Config portion of the st_sorter is separate to allow it be be persistent.
*)
st_sorter.Config := st_sorterCfg;
Sorter_P6040(st_Sorter := st_Sorter
		, In_ItemToInduct := st_ToInduct.Item
		, In_InductingItem := st_Inducting.Item
		, aItems := aSorterItems
		, aDiverts := Diverts
		, st_tempItem := st_TempItem);

//-------------------------------------------------DivertCfg--------------------------------------------------------------
(*
	Initialize Diverts here. 
	Tie variables commented IO to physical IO address
*)

//Divert #1
Diverts[1].Config := DivertsCfgs[1];
Diverts[1].ConfirmPE := Photoeyes.PE_7191.Out; 			
Diverts[1].FullPE := Photoeyes.PE_7191.Out;   			

//Divert #2
Diverts[2].Config := DivertsCfgs[2];
Diverts[2].ConfirmPE := Photoeyes.PE_7241.Out; 		
Diverts[2].FullPE := Photoeyes.PE_7241.Out;   		

//Divert #3 
Diverts[3].Config := DivertsCfgs[3];
Diverts[3].ConfirmPE := Photoeyes.PE_8171.Out; 		
Diverts[3].FullPE := Photoeyes.PE_8171.Out;   	

//Divert #4 
Diverts[4].Config := DivertsCfgs[4];
Diverts[4].ConfirmPE := Photoeyes.PE_8221.Out; 		
Diverts[4].FullPE := Photoeyes.PE_8221.Out; 

//Divert #5
Diverts[5].Config := DivertsCfgs[5];
//Diverts[5].ConfirmPE := Photoeyes.PE_8221.Out; 		
//Diverts[5].FullPE := Photoeyes.PE_8221.Out; 	

// Logging
// Divert 1
Divert_RTRIG[1](CLK := Diverts[1].Output1);
IF Divert_RTRIG[1].q THEN
	IF .nDivertLogEnable.DIVERT1 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[1].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[1].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 1 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
Divert_FTRIG[1](CLK := Diverts[1].Output1);
IF Divert_FTRIG[1].q THEN
	IF .nDivertLogEnable.DIVERT1 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[1].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[1].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 1 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
// Divert 2
Divert_RTRIG[2](CLK := Diverts[2].Output1);
IF Divert_RTRIG[2].q THEN
	IF .nDivertLogEnable.DIVERT2 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[2].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[2].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 2 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
Divert_FTRIG[2](CLK := Diverts[2].Output1);
IF Divert_FTRIG[2].q THEN
	IF .nDivertLogEnable.DIVERT2 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[2].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[2].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 2 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
// Divert 3
Divert_RTRIG[3](CLK := Diverts[3].Output1);
IF Divert_RTRIG[3].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[3].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[3].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 3 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
Divert_FTRIG[3](CLK := Diverts[3].Output1);
IF Divert_FTRIG[3].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[3].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[3].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 3 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
			
// Divert 4
Divert_RTRIG[4](CLK := Diverts[4].Output1);
IF Divert_RTRIG[4].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[4].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[4].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 4 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
Divert_FTRIG[4](CLK := Diverts[4].Output1);
IF Divert_FTRIG[4].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[4].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[4].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 4 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF

// Divert 5
Divert_RTRIG[5](CLK := Diverts[5].Output1);
IF Divert_RTRIG[5].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[5].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[5].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 4 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
Divert_FTRIG[5](CLK := Diverts[5].Output1);
IF Divert_FTRIG[5].q THEN
	IF .nDivertLogEnable.DIVERT3 THEN
		sMessage := CONCAT(BOOL_TO_STRING(Diverts[5].Output1),' Item: ');
		sMessage := CONCAT(sMessage,Diverts[5].Item.ID);
		// Write to the Error List
		ADSLOGSTR( msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG
			, msgFmtStr := 'Divert 5 Extend : %s'
			, strArg := sMessage);
	END_IF
END_IF
//---------------------------------------------DivertCfg End------------------------------------------------------------------

// Log the diverts
Log_Diverts();
]]></ST>
    </Implementation>
    <LineIds Name="Sorter">
      <LineId Id="61" Count="18" />
      <LineId Id="5" Count="0" />
      <LineId Id="100" Count="11" />
      <LineId Id="113" Count="0" />
      <LineId Id="122" Count="1" />
      <LineId Id="114" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="125" Count="3" />
      <LineId Id="130" Count="35" />
      <LineId Id="173" Count="56" />
      <LineId Id="302" Count="0" />
      <LineId Id="306" Count="146" />
      <LineId Id="305" Count="0" />
      <LineId Id="304" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="231" Count="1" />
      <LineId Id="99" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>